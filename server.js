const isProduction = process.env.NODE_ENV === 'production'
const isStaging = process.env.NODE_ENV === 'staging'
const isDevelopment = !isProduction && !isStaging

const fs = require('fs')
const path = require('path')
const express = require('express')
const compression = require('compression')
const cookieParser = require('cookie-parser')

const resolve = file => path.resolve(__dirname, file)

const app = express()
const template = fs.readFileSync(
  resolve('./public/index.template.html'),
  'utf-8'
)

let renderer
let readyPromise

function createRenderer(bundle, options) {
  return require('vue-server-renderer').createBundleRenderer(
    bundle,
    Object.assign(options, {
      template,
      basedir: resolve('./dist'),
      runInNewContext: false,
      shouldPreload: (file, type) => {
        if (type === 'script' || type === 'style') {
          return true
        }
        else if (type === 'font') {
          return /\.woff2$/.test(file)
        }
        else {
          return false
        }
      },
      shouldPrefetch: (file, type) => {
        return false
      }
    })
  )
}

function serve(path, cache = false) {
  return express.static(resolve(path), {
    setHeaders(res) {
      if (cache) {
        res.setHeader('Cache-Control', cache)
      }
      res.setHeader('Service-Worker-Allowed', '/')
    }
  })
}

if (isProduction || isStaging) {
  // In production: create server renderer using built server bundle.
  // The server bundle is generated by vue-ssr-webpack-plugin.
  const bundle = require('./dist/vue-ssr-server-bundle.json')

  // The client manifests are optional, but it allows the renderer
  // to automatically infer preload/prefetch links and directly add <script>
  // tags for any async chunks used during render, avoiding waterfall requests.
  const clientManifest = require('./dist/vue-ssr-client-manifest.json')
  renderer = createRenderer(bundle, {
    clientManifest
  })
} else {
  // In development: setup the dev server with watch and hot-reload,
  // and create a new renderer on bundle / index template update.
  readyPromise = require('./build/setup-dev-server')(app, (bundle, options) => {
    try {
      renderer = createRenderer(bundle, options)
    } catch (e) {
      console.error(e)
    }
  })

  // Dangerous, should only run in development.
  process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = 0
}


app.use(compression({
  threshold: 0
}))
app.use(cookieParser())

app.use('/dist/vue-ssr-client-manifest.json', serve('./dist/vue-ssr-client-manifest.json', 'max-age=60, stale-while-revalidate=30'))
app.use('/dist', serve('./dist', isDevelopment ? false : 'public, max-age=31557600'))
app.use('/public', serve('./public', 'max-age=3600, stale-while-revalidate=60'))
function render(req, res, context) { 

  !isProduction && console.log(`Rendering: ${req.url}`)

  res.setHeader('Content-Type', 'text/html')
  res.setHeader('Cache-Control', 'public, max-age=0, must-revalidate') 

  renderToString(context, res)
}

function renderToString(context, res) {
  const s = Date.now()
  const errorHandler = err => {
    if (err.url) {
      res.redirect(err.url)
      return
    }

    if (!isProduction) {
      console.error(err)
    }

    res.status(500)
    res.end()

    !isProduction && console.log(`Whole request: ${Date.now() - s}ms`)
  }

  renderer.renderToString(context, (err, html) => {
    if (err) return errorHandler(err)

    // Overwrite Cache-Control (set above) if the page requests it
    if (context.expiryDate) {
      var expiryDate = new Date(context.expiryDate)
      var seconds = Math.abs((new Date().getTime() - expiryDate.getTime()) / 1000).toFixed(0);

      context.headers['Cache-Control'] = 'public' //, max-age=' + Math.abs((new Date().getTime() - expiryDate.getTime()) / 1000).toFixed(0)
      context.headers.Expires = expiryDate.toUTCString()
      context.headers.Vary = context.headers.Vary || 'Accept-Encoding'
    }

    // Set any headers providing during render
    res.set(context.headers)

    // Override the responses status code with
    // one provided by a view component.
    res.status(context.httpStatusCode)
    res.end(html)

    !isProduction && console.log(`Whole request: ${Date.now() - s}ms`)
  })
}

// Anything that no longer exists in dist will hit this
app.get('/dist/*', (req, res) => {
  res.status(404).send()
})

app.get('*', (req, res) => {
  const context = {
    url: req.url,
    fullUrl: `${req.protocol}://${req.get('host')}${req.originalUrl}`,
    origin: `${req.protocol}://${req.get('host')}`,
    locale: req.cookies.locale || req.locale || 'en',
    httpStatusCode: 200,
    headers: {},
    hostname: req.hostname
  }

  isProduction || isStaging ?
    render(req, res, context) :
    readyPromise.then(() => render(req, res, context))
})

let port = process.env.PORT || 8081


let server = app.listen(port, () => {
  console.log(`[${process.env.NODE_ENV || 'development'}] Server started at localhost:${port}`)
})

process.on('SIGTERM', shutDown);
process.on('SIGINT', shutDown);

process.on('uncaughtException', function(e) {
  console.error('Ouch, an unhandled exception');
  
  console.error(e);
  process.exit(1);
});

function shutDown() {
  console.log('Received kill signal, shutting down gracefully');
  server.close(() => {
    console.log('Closed out remaining connections');
    process.exit(0);
  });

  setTimeout(() => {
    console.error('Could not close connections in time, forcefully shutting down');
    process.exit(1);
  }, 10000);
}

module.exports = {
  ready: readyPromise,
  close: () => {
    server.close()
  }
}
